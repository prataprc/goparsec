Parser library using top-down recursive backtracking employing parser-combinators.
To know more about theory of parser combinators,
refer to : http://en.wikipedia.org/wiki/Parser_combinator

This package contains following components,

* standard set of combinators, parsing algorithms can create input specific
  combinator functions on top of the standard set.
* regular expression based scanner.
* standard set of terminal tokens.

**combinators**

Every combinator should confirm to the following signature,

.. code-block:: go

    type ParsecNode interface{} // Can be used to construct AST.
    type Parser func(Scanner) (ParsecNode, *Scanner) // combinable parsers
    type Nodify func([]ParsecNode) ParsecNode

    func Combinator(callb Nodify, parsers ...Parser) Parser {

you can see that combinators take a variable number of parser functions and
return a new parser function.

`Nodify` is user supplied callback function, called by combinators when it
matches current input text. The callback function receives a collection of
parsecNode interface generated by `parsers`.

A `Parser` function must take a new copy of `Scanner` instance, with current
cursor, as argument, and consume the scanner as long as there is a match. If
the parser could not match with input text it returns the scanner without
consuming any input. For example, the following snippet is from `And`
combinator,

.. code-block:: go

    news := &s
    for _, parser := range parsers {
        n, news = parser(*news)
        if n == nil {
            return docallback(callb, []ParsecNode{}), &s
        }
        ns = append(ns, n)
    }
    return docallback(callb, ns), news

we can see that a new instance of `s` is passed to each `parser` and when one
of the parser returns failure (where n==nil), it simply returns the scanner
without consuming any tokens. Otherwise, it returns the new-scanner `news`
returned by the last parser.

And:
    accepts a collection of parsers that must sequentially match current
    input text.

    nodify callback is called with a slice of parsecNodes obtained from each
    parser. Otherwise called with empty-slice of parsecNodes.

OrdChoice:
    accepts a collection of parsers, where atleat one of the parser should
    match current input text.

    nodify callback is called with a slice of single parsecNode element when
    one of the input parser matches with input text. Otherwise called with
    empty-slice of parsecNodes. When a parser matches the input text remaining
    parsers are not tried.

Kleene:
    accepts a pair of parser, where the first element must match `zero or more
    times` with current input text and the second optional element acts as token
    separator. Note that the Kleene repeatition will exit when first parser or
    second parser, if specified, fails.

    nodify callback is called with a slice of parsecNodes obtained from every
    match of the first parser. Otherwise called with empty-slice of parsecNodes.

Many:
    accepts a pair of parser, where the first element must match `one or more
    times` with current input text and the second optional element acts as token
    separator. Note that the Many repeatition will exit when first parser or
    second parser, if specified, fails.

    nodify callback is called with a slice of parsecNodes obtained from every
    match of the first parser. Otherwise called with empty-slice of parsecNodes.

Maybe:
    accepts a parser that can either match or does-not-match with current
    input text.

    nodify callback is called with a slice of single parsecNode element if
    `Maybe` succeeds. Otherwise called with empty-slice of parsecNodes.

**using the scanner**

The builtin scanner library manages the input buffer and a cursor into the
buffer. Create a new scanner instance,

.. code-block:: go

    s := parsec.NewScanner(text)
    rootParser(s)

the scanner library supplies method receivers like `Match()`, `SkipWS()` and
`Endof()`. refer to scanner.go for more information on each of these methods.

Check out this example program that uses `parsec` tool to do arithmetic
expression evaluation for integers, 
https://github.com/prataprc/goparsec/blob/master/examples/expr.go.

.. code-block:: bash

    > cd examples/
    > go run expr.go eg.expr

to run the example program.
